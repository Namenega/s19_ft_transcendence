import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/createUser.dto';
import { UpdateUserDto } from './dto/updateUser.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { UserEntity } from './entities/user.entity';

/* Importing the speakeasy library. */
const speakeasy = require('speakeasy');
/* Importing the bcrypt library. */
const bcrypt = require('bcrypt');


@Injectable()
export class UsersService {
	/**
	 * The constructor function is a special function that is called when a new
	 * instance of the class is created
	 * @param UserRepo - Repository<UserEntity>
	 */
	constructor(
		@InjectRepository(UserEntity)
		private UserRepo: Repository<UserEntity>
	) {}

	/**
	 * It takes a CreateUserDto object, saves it to the database, and returns a
	 * UserEntity object
	 * @param {CreateUserDto} createUserDto - CreateUserDto - This is the DTO that we
	 * created earlier.
	 * @returns The user entity that was created.
	 */
	async create(createUserDto: CreateUserDto): Promise<UserEntity> {
		return await this.UserRepo.save(createUserDto);
	}

	/**
	 * It returns a promise of an array of UserEntity objects
	 * @returns An array of UserEntity objects
	 */
	async findAll(): Promise<UserEntity[]> {
		return await this.UserRepo.find();
	}

	async findAllRank(): Promise<UserEntity[]> {
		return await this.UserRepo.find({order: {numberOfWin: "DESC"}});
	}

	/**
	 * It returns a promise of a UserEntity
	 * @param {number} id - number - The id of the user we want to find
	 * @returns A promise of a UserEntity
	 */
	async findOne(id: number): Promise<UserEntity> {
		return await this.UserRepo.findOne(id);
	}

	/**
	 * This function returns a user entity with all of its relations
	 * @param {number} id - number - The id of the user you want to find
	 * @returns The user with the given id, with all of the relations loaded.
	 */
	async findCompleteOne(id: number): Promise<UserEntity> {
		return await this.UserRepo.findOne(id, {
			relations: ['matchHistory', 'friends', 'dms', 'channels']
		});
	}

	/**
	 * Find a user by name.
	 * @param {string} name - The name of the function
	 * @returns A promise of a UserEntity
	 */
	async findOneByName(name: string): Promise<UserEntity> {
		return await this.UserRepo.findOne({ where: { name: name }});
	}

	/**
	 * Find one user by login.
	 * @param {string} login - string - the login of the user we want to find
	 * @returns The user entity with the matching login.
	 */
	async findOneByLogin(login: string): Promise<UserEntity> {
		return await this.UserRepo.findOne({ where: { login: login }});
	}

	/* Updating the user's information in the database. */
	async update(id: number, updateUserDto: UpdateUserDto): Promise<void> {
		await this.UserRepo.update(id, updateUserDto);
	} //"TypeORM bug: Cannot query across many-to-many for property channels" | .update method often bugs and does not return, .save may be a better alternative

	/**
	 * "Delete a user from the database."
	 * 
	 * The first line of the function is a TypeScript annotation. It tells us that the
	 * function returns a Promise of type void
	 * @param {number} id - number - The id of the user to delete
	 */
	async remove(id: number): Promise<void> {
		await this.UserRepo.delete(id);
	}

	/**
	 * It generates a secret for two factor authentication
	 * @returns A secret key for two-factor authentication.
	 */
	twoFactorAuthenticationSecret(): any {
		return speakeasy.generateSecret({ name: 'Pong Game' });
	}

	/**
	 * It takes a secret and a token, and returns true if the token is valid for the
	 * secret
	 * @param {string} secret - The secret key that was generated in the previous
	 * step.
	 * @param {string} token - The token generated by the user's app.
	 * @returns A boolean value.
	 */
	verifyTwoFactorAuthentication(secret: string, token: string): boolean {
		const res = speakeasy.totp.verify({
			secret: secret,
			encoding: 'ascii',
			token: token
		});
		return res;
	}

	/**
	* It takes in a user's id and password, finds the user in the database, and
	* compares the password the user entered with the password in the database
	* @param {number} id - number - the id of the user
	* @param {string} password - the password that the user entered in the login
	* form
	* @returns A boolean value.
	*/
	async passwordVerification(id: number, password: string): Promise<boolean> {
		const user = await this.UserRepo.findOne(id);
		return await bcrypt.compare(password, user.password); //compare non-encrypted-password with encrypted-password-in-database using bcrypt
	}
}
