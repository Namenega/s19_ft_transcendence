import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CreateUserDto } from './dto/createUser.dto';
import { UpdateUserDto } from './dto/updateUser.dto';
import { UserEntity } from './entities/user.entity';

/* Importing the speakeasy library. */
const speakeasy = require('speakeasy');
/* Importing the bcrypt library. */
const bcrypt = require('bcrypt');


@Injectable()
export class UsersService {
	/**
	 * The constructor function is a special function that is called when a new
	 * instance of the class is created
	 * @param UserRepo - Repository<UserEntity>
	 */
	constructor(
		@InjectRepository(UserEntity)
		private UserRepo: Repository<UserEntity>
	) {}

	/**
	 * It takes a CreateUserDto object, saves it to the database, and returns a
	 * UserEntity object
	 * @param {CreateUserDto} createUserDto - CreateUserDto - This is the DTO that we
	 * created earlier.
	 * @returns The user entity that was created.
	 */
	async create(createUserDto: CreateUserDto): Promise<UserEntity> {
		try {
			return await this.UserRepo.save(createUserDto);
		} catch (error) {
			throw error;
		}
	}

	/**
	 * It returns a promise of an array of UserEntity objects
	 * @returns An array of UserEntity objects
	 */
	async findAll(): Promise<UserEntity[]> {
		try {
			return await this.UserRepo.find();
		} catch (error) {
			throw error;
		}
	}

	/**
	 * It returns a list of users sorted by the number of wins
	 * @returns An array of UserEntity
	 */
	async findAllRank(): Promise<UserEntity[]> {
		try {
			return await this.UserRepo.find({order: {elo: "DESC"}});
		} catch (error) {
			throw error;
		}
	}

	/**
	 * It returns a promise of a UserEntity
	 * @param {number} id - number - The id of the user we want to find
	 * @returns A promise of a UserEntity
	 */
	async findOne(id: number): Promise<UserEntity> {
		try {
			return await this.UserRepo.findOne({ where: { id } });
		} catch (error) {
			throw error;
		}
	}

	/**
	 * This function returns a user entity with all of its relations
	 * @param {number} id - number - The id of the user you want to find
	 * @returns The user with the given id, with all of the relations loaded.
	 */
	async findCompleteOne(id: number): Promise<UserEntity> {
		try {
			return await this.UserRepo.findOne({ where: { id },
				relations: ['matchHistory', 'friends', 'dms', 'channels']
			});
		} catch (error) {
			throw error;
		}
	}

	/**
	 * Find a user by name.
	 * @param {string} name - The name of the function
	 * @returns A promise of a UserEntity
	 */
	async findOneByName(name: string): Promise<UserEntity> {
		try {
			return await this.UserRepo.findOne({ where: { name: name }});
		} catch (error) {
			throw error;
		}
	}

	/**
	 * Find one user by login.
	 * @param {string} login - string - the login of the user we want to find
	 * @returns The user entity with the matching login.
	 */
	async findOneByLogin(login: string): Promise<UserEntity> {
		try {
			return await this.UserRepo.findOne({ where: { login: login }});
		} catch (error) {
			throw error;
		}
	}

	/* Updating the user's information in the database. */
	async update(id: number, updateUserDto: UpdateUserDto): Promise<void> {
		try {
			await this.UserRepo.update(id, updateUserDto);
		} catch (error) {
			throw error;
		}
	} //"TypeORM bug: Cannot query across many-to-many for property channels" | .update method often bugs and does not return, .save may be a better alternative

	/**
	 * "Delete a user from the database."
	 * 
	 * The first line of the function is a TypeScript annotation. It tells us that the
	 * function returns a Promise of type void
	 * @param {number} id - number - The id of the user to delete
	 */
	async remove(id: number): Promise<void> {
		try {
			await this.UserRepo.delete(id);
		} catch (error) {
			throw error;
		}
	}

	/**
	 * It generates a secret for two factor authentication
	 * @returns A secret key for two-factor authentication.
	 */
	twoFactorAuthenticationSecret(): any {
		try {
			return speakeasy.generateSecret({ name: 'Pong Game' });
		} catch (error) {
			throw error;
		}
	}

	/**
	 * It takes a secret and a token, and returns true if the token is valid for the
	 * secret
	 * @param {string} secret - The secret key that was generated in the previous
	 * step.
	 * @param {string} token - The token generated by the user's app.
	 * @returns A boolean value.
	 */
	verifyTwoFactorAuthentication(secret: string, token: string): boolean {
		try {
			const res = speakeasy.totp.verify({
				secret: secret,
				encoding: 'ascii',
				token: token
			});

			return res;
		}
		catch (error) {
			throw error;
		}
	}

	/**
	* It takes in a user's id and password, finds the user in the database, and
	* compares the password the user entered with the password in the database
	* @param {number} id - number - the id of the user
	* @param {string} password - the password that the user entered in the login
	* form
	* @returns A boolean value.
	*/
	async passwordVerification(id: number, password: string): Promise<boolean> {
		try {
			let user = await this.UserRepo.findOne({ where: { id } });
			// user = undefined;

			return await bcrypt.compare(password, user.password); //compare non-encrypted-password with encrypted-password-in-database using bcrypt
			
		} catch (error) {
			throw error; 
		}
	}
}
